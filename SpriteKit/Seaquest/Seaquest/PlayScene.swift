////  PlayScene.swift//  Seaquest////  Created by Marcio Barros on 11/26/14.//  Copyright (c) 2014 UNIRIO. All rights reserved.//import SpriteKitimport AVFoundationstruct PhysicsCategory {    static let None      : UInt32 = 0    static let Submarine : UInt32 = 0b001    static let Diver     : UInt32 = 0b010    static let Shark     : UInt32 = 0b100}class PlayScene: SKScene, SKPhysicsContactDelegate {	var azymuth = SKSpriteNode(imageNamed: "azymuth")	var seaFloor = SKSpriteNode(imageNamed: "seafloor")    var submarine = SKSpriteNode(imageNamed: "submarine")	var navigationArea : CGRect!    var oxygen = 100.0    var oxygenUsed : SKShapeNode!    var sharks : [SKSpriteNode] = []	var divers : [SKSpriteNode] = []	var lifeNodes : [SKSpriteNode] = []    var remainingLifes = 3    var scoreNode = SKLabelNode()    var score = 0	var gamePaused = false		/*	 * Prepares the elements handled in the scene	 */    override func didMove(to view: SKView) {		setupPhysicsWorld()		createBackground()		createOxygenBar()		createSubmarine()		createSharksAndDivers()		createStatusBar()    }		/*	 * Setup the characteristics of the physics world used in the scene	 */	func setupPhysicsWorld() {		physicsWorld.gravity = CGVector(dx: 0, dy: 0)		physicsWorld.contactDelegate = self	}		/*	 * Creates the scene background and computes the navigation area	 */	func createBackground() {		backgroundColor = UIColor(hex: 0x0000FF)			azymuth.anchorPoint = CGPoint(x: 0.0, y: 1.0)		azymuth.position = CGPoint(x: frame.minX, y: frame.maxY - 40)		addChild(azymuth)				seaFloor.anchorPoint = CGPoint(x: 0.0, y: 1.0)		seaFloor.position = CGPoint(x: frame.minX, y: frame.minY + seaFloor.size.height + 30)		addChild(seaFloor)			let minNavigationY = frame.minY + seaFloor.size.height + 40 + submarine.size.height / 2		let maxNavigationY = frame.maxY - azymuth.size.height - 50 + submarine.size.height / 2		let minNavigationX = frame.minX + 10 + submarine.size.width / 2		let maxNavigationX = frame.maxX - 10 - submarine.size.width / 2		navigationArea = CGRect(x: minNavigationX, y: minNavigationY, width: maxNavigationX - minNavigationX + 1, height: maxNavigationY - minNavigationY + 1)	}		/*	 * Creates the oxygen bar in the lower part of the scene	 */	func createOxygenBar() {		let oxygenWidth = (frame.maxX - frame.minX) * 0.70		let rect = CGRect(x: (frame.maxX - frame.minX - oxygenWidth) / 2, y: frame.minY + 10, width: oxygenWidth, height: 15)				let oxygenRectangle = SKShapeNode()		oxygenRectangle.path = CGPath(rect: rect, transform: nil)		oxygenRectangle.fillColor = UIColor.white		addChild(oxygenRectangle)			oxygenUsed = SKShapeNode()		updateOxygenBar()		addChild(oxygenUsed)				let label = SKLabelNode(fontNamed: "Arial-BoldMT")		label.text = "OxigÃªnio"		label.fontSize = 12		label.position = CGPoint(x: frame.minX + 50, y: frame.minY + 12)		addChild(label)	}		/*	 * Creates the submarine	 */	func createSubmarine() {		let posSubmarineX = navigationArea.minX + (navigationArea.maxX - navigationArea.minX) / 2		let posSubmarineY = navigationArea.minY + (navigationArea.maxY - navigationArea.minY) / 2			submarine.position = CGPoint(x: posSubmarineX, y: posSubmarineY)		submarine.anchorPoint = CGPoint(x: 0.5, y: 0.5)		addChild(submarine)			submarine.physicsBody = SKPhysicsBody(rectangleOf: submarine.size)		submarine.physicsBody?.isDynamic = false		submarine.physicsBody?.categoryBitMask = PhysicsCategory.Submarine		submarine.physicsBody?.contactTestBitMask = PhysicsCategory.Shark | PhysicsCategory.Diver		submarine.physicsBody?.collisionBitMask = PhysicsCategory.None	}		/*	 * Creates all sharks and their respective divers	 */	func createSharksAndDivers() {		for i in 0...3 {			let shark = createShark(i)			sharks += [shark]			let diver = createDiver(i)			divers += [diver]			resetSharkAndDiver(shark, diver: diver)		}	}		/*	 * Creates an animated shark	 */	func createShark(_ index: Int) -> SKSpriteNode {		let shark = SKSpriteNode(imageNamed: "shark1")        shark.position = CGPoint(x: -100, y: navigationArea.minY + CGFloat(index * 45) - shark.size.height / 2)        shark.anchorPoint = CGPoint(x: 0.5, y: 0.5)        addChild(shark)	        shark.physicsBody = SKPhysicsBody(rectangleOf: shark.size)        shark.physicsBody?.isDynamic = true        shark.physicsBody?.categoryBitMask = PhysicsCategory.Shark        shark.physicsBody?.contactTestBitMask = PhysicsCategory.Submarine        shark.physicsBody?.collisionBitMask = PhysicsCategory.None	        let animationTexture = SKAction.animate(with: [			SKTexture(imageNamed: "shark1"),			SKTexture(imageNamed: "shark2")], timePerFrame: 0.2)                let sharkAnimation = SKAction.repeatForever(animationTexture)        shark.run(sharkAnimation)		return shark;	}		/*	 * Creates an animated diver	 */    func createDiver(_ index: Int) -> SKSpriteNode{        let diver = SKSpriteNode(imageNamed: "diver1")        diver.position = CGPoint(x: -100, y: navigationArea.minY + 5 + CGFloat(index * 45) - diver.size.height / 2)        diver.anchorPoint = CGPoint(x: 0.5, y: 0.5)        addChild(diver)	        diver.physicsBody = SKPhysicsBody(rectangleOf: diver.size)        diver.physicsBody?.isDynamic = true        diver.physicsBody?.categoryBitMask = PhysicsCategory.Diver        diver.physicsBody?.contactTestBitMask = PhysicsCategory.Submarine        diver.physicsBody?.collisionBitMask = PhysicsCategory.None	        let animationTexture = SKAction.animate(with: [			SKTexture(imageNamed: "diver1"),			SKTexture(imageNamed: "diver2"),			SKTexture(imageNamed: "diver3")], timePerFrame: 0.2)                let diverAnimation = SKAction.repeatForever(animationTexture)        diver.run(diverAnimation)				return diver;    }		/*	 * Creates the status bar for the game	 */	func createStatusBar() {        let hud = SKSpriteNode(texture: nil, size: CGSize(width: self.size.width, height: self.size.height*0.05))        hud.anchorPoint=CGPoint(x: 0, y: 0)        hud.position = CGPoint(x: 0, y: self.size.height-hud.size.height)        self.addChild(hud)                let lifeSize = CGSize(width: hud.size.height-10, height: hud.size.height-10)		        for i in 1...remainingLifes {            let lifeNode = SKSpriteNode(imageNamed: "submarine")			lifeNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)            lifeNode.size = lifeSize            lifeNode.position=CGPoint(x: lifeNode.size.width * 1.3 * CGFloat(i), y: (hud.size.height - 5) / 2)            hud.addChild(lifeNode)            lifeNodes += [lifeNode]        }        		self.scoreNode.position = CGPoint(x: hud.size.width * 0.9, y: 1)        self.scoreNode.text = "0"        self.scoreNode.fontSize = hud.size.height		self.scoreNode.fontName = "Arial Bold"        hud.addChild(self.scoreNode)    }		/*	 * Detects a contact between two sprites	 */    func didBegin(_ contact: SKPhysicsContact) {		if (gamePaused) {			return		}                if (contact.bodyA.categoryBitMask == PhysicsCategory.Submarine && contact.bodyB.categoryBitMask == PhysicsCategory.Shark) {			die()        }        else if (contact.bodyA.categoryBitMask == PhysicsCategory.Shark && contact.bodyB.categoryBitMask == PhysicsCategory.Submarine) {			die()        }		else if (contact.bodyA.categoryBitMask == PhysicsCategory.Submarine && contact.bodyB.categoryBitMask == PhysicsCategory.Diver) {			captureDiver(contact.bodyB.node!)        }		else if (contact.bodyA.categoryBitMask == PhysicsCategory.Diver && contact.bodyB.categoryBitMask == PhysicsCategory.Submarine) {			captureDiver(contact.bodyA.node!)        }    }		/*	 * Captures a diver and increase score	 */	func captureDiver(_ diver: SKNode) {		if (diver.alpha > 0.0) {			score += 1			self.scoreNode.text = String(score)			diver.alpha = CGFloat(0.0)			run(SKAction.playSoundFileNamed("button-09.wav", waitForCompletion: false))		}	}    	/*	 * Returns a nniform [0, 1] number	 */    func random() -> Float {        return Float(arc4random()) / Float(UINT32_MAX)    }		/*	 * Reset the position of a shark/diver pair after they completed a run through the screen	 */    func resetSharkAndDiver(_ shark: SKSpriteNode, diver: SKSpriteNode) {		shark.removeAction(forKey: "run")		diver.removeAction(forKey: "run")	        let distanceToShark = 5 + random() * 10		diver.alpha = CGFloat(+1.0)                if (random() > 0.5) {			prepareSharkAndDiverFromLeft(shark, diver: diver, distanceToShark: distanceToShark)		} else {			prepareSharkAndDiverFromRight(shark, diver: diver, distanceToShark: distanceToShark)        }    }		/*	 * Reset the position of a shark/diver pair moving left-to-right	 */	func prepareSharkAndDiverFromLeft(_ shark: SKSpriteNode, diver: SKSpriteNode, distanceToShark: Float) {		shark.xScale = CGFloat(+1.0)		shark.position = CGPoint(x: -diver.size.width-shark.size.width-CGFloat(distanceToShark), y: shark.position.y)		let sharkMove = SKAction.move(to: CGPoint(x: navigationArea.maxX + 50, y: shark.position.y), duration: 8)				diver.xScale = CGFloat(+1.0)		diver.position = CGPoint(x: -diver.size.width, y: diver.position.y)		let diverMove = SKAction.move(to: CGPoint(x: navigationArea.maxX + 50 + shark.size.width + CGFloat(distanceToShark), y: diver.position.y), duration: 8)                let interval = CFTimeInterval(random() * 5)        let diverWait = SKAction.wait(forDuration: interval)                diver.run(diverWait, completion: {			shark.run(SKAction.sequence([sharkMove, SKAction.run { self.resetSharkAndDiver(shark, diver: diver) }]), withKey: "run")			diver.run(diverMove, withKey: "run")        })	}		/*	 * Reset the position of a shark/diver pair moving right-to-left	 */	func prepareSharkAndDiverFromRight(_ shark: SKSpriteNode, diver: SKSpriteNode, distanceToShark: Float) {		shark.xScale = CGFloat(-1.0)		shark.position = CGPoint(x: navigationArea.maxX + submarine.size.width + diver.size.width + CGFloat(distanceToShark) + 20, y: diver.position.y)		let sharkMove = SKAction.move(to: CGPoint(x: navigationArea.minX - 50, y: shark.position.y), duration: 8)				diver.xScale = CGFloat(-1.0)		diver.position = CGPoint(x: navigationArea.maxX + submarine.size.width + 20, y: diver.position.y)		let diverMove = SKAction.move(to: CGPoint(x: navigationArea.minX - 50 - diver.size.width - CGFloat(distanceToShark), y: diver.position.y), duration: 8)                let interval = CFTimeInterval(random() * 5)        let diverWait = SKAction.wait(forDuration: interval)                diver.run(diverWait, completion: {			shark.run(sharkMove, withKey: "run")			diver.run(SKAction.sequence([diverMove, SKAction.run { self.resetSharkAndDiver(shark, diver: diver) }]), withKey: "run")        })	}    	/*	 * Detects the event that triggers moving the submarine	 */	override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {		if (!gamePaused) {			for touch in touches {				let location = touch.location(in: self)				moveSubmarine(location)			}		}    }		/*	 * Moves the submarine to a given point in the screen	 */	func moveSubmarine(_ location: CGPoint) {		let newX = min(max(navigationArea.minX, location.x), navigationArea.maxX)		let newY = min(max(navigationArea.minY, location.y), navigationArea.maxY)		let actionMove = SKAction.move(to: CGPoint(x: newX, y: newY), duration: 0.5)		submarine.xScale = CGFloat(location.x < submarine.position.x ? -1.0 : 1.0)		submarine.removeAllActions()		submarine.run(actionMove)	}		/*	 * Updates oxygen on each frame	 */    override func update(_ currentTime: TimeInterval) {		if (!gamePaused) {			updateOxygen()		}	}		/*	 * Decreases or increases the oxygen tank according to submarine position	 */	func updateOxygen() {		let y = Int(ceil(submarine.position.y))		let maxY = Int(ceil(navigationArea.maxY))	        if y >= maxY {			oxygen = min(oxygen+1, 100)		}        else {			oxygen -= 0.1			if (oxygen < 0) { die(); oxygen = 0.0 }        }        		updateOxygenBar()	}		/*	 * Draws the oxygen bar according to current oxygen	 */	func updateOxygenBar() {		let minX = frame.minX        let maxX = frame.maxX        let minY = frame.minY			let oxygenWidth = (maxX - minX) * 0.70		let rectUsed = CGRect(x: (maxX - minX - oxygenWidth) / 2, y: minY+10, width: oxygenWidth * CGFloat(oxygen / 100.0), height: 15)		oxygenUsed.path = CGPath(rect: rectUsed, transform: nil)        oxygenUsed.fillColor = (oxygen > 20) ? UIColor.green : UIColor.red	}    	/*	 * Kills the current submarine	 */    func die() {		self.gamePaused = true		run(SKAction.playSoundFileNamed("button-10.wav", waitForCompletion: true))		submarine.removeAllActions()				if self.remainingLifes > 0 {			self.lifeNodes[remainingLifes-1].alpha = 0.0			self.remainingLifes -= 1;		}					if (self.remainingLifes == 0) {			showGameOver()			return		}					submarine.run(SKAction.fadeOut(withDuration: 1), completion: {			self.prepareNewLife()						self.submarine.run(SKAction.fadeIn(withDuration: 1), completion: {				self.gamePaused = false			})		})    }		/*	 * Prepares a new life for the submarine	 */	func prepareNewLife() {		self.submarine.position = CGPoint(x: self.size.width/2, y: self.size.height/2)		self.oxygen = 100				for i in 0...3 {			self.resetSharkAndDiver(sharks[i], diver: divers[i])		}	}		/*	 * Shows the game over dialog	 */	func showGameOver() {		self.gamePaused = true		submarine.run(SKAction.fadeOut(withDuration: 1))				let alert = UIAlertController(title: "Game Over", message: "", preferredStyle: UIAlertControllerStyle.alert)		alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.default) { _ in							self.remainingLifes=3			for lifeNode in self.lifeNodes {				lifeNode.alpha = 1.0			}						self.score = 0			self.scoreNode.text = String(0)			self.submarine.alpha = 1.0			self.prepareNewLife()			self.gamePaused = false		})					self.view?.window?.rootViewController?.present(alert, animated: true, completion: nil)	}}